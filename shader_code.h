/* File generated with Shader Minifier 1.1.4
 * http://www.ctrl-alt-test.fr
 */
#ifndef SHADER_CODE_H_
# define SHADER_CODE_H_

const char *fun_fs =
 "float v(vec3 v,float y)"
 "{"
   "return length(v)-y;"
 "}"
 "float v(vec3 v,vec3 x,float y)"
 "{"
   "return length(max(abs(v)-x,0.))-y;"
 "}"
 "float v(vec3 v,vec3 x,vec3 m,float y)"
 "{"
   "vec3 i=v-x,f=m-x;"
   "float l=clamp(dot(i,f)/dot(f,f),0.,1.);"
   "return length(i-f*l)-y;"
 "}"
 "float h(vec3 v,vec2 y)"
 "{"
   "vec2 i=abs(vec2(length(v.xz),v.y))-y;"
   "return min(max(i.x,i.y),0.)+length(max(i,0.));"
 "}"
 "float m(vec3 v,vec3 y)"
 "{"
   "if(length(v)<20.)"
     "return length(v.yx-y.yz)-y.x;"
   "else"
     " return 1.;"
 "}"
 "float f(float v,float y)"
 "{"
   "return max(-y,v);"
 "}"
 "vec2 n(vec2 v,vec2 y)"
 "{"
   "return v.x<y.x?v:y;"
 "}"
 "float x(float v,float y)"
 "{"
   "return min(v,y);"
 "}"
 "float f(vec2 v)"
 "{"
   "return v=v*v,v=v*v,v=v*v,pow(v.x+v.y,.125);"
 "}"
 "float s(vec3 v,vec2 y)"
 "{"
   "vec2 i=vec2(f(v.xy)-y.x,v.z);"
   "return f(i)-y.y;"
 "}"
 "float i(vec3 v,vec2 y)"
 "{"
   "vec2 i=abs(vec2(length(v.xz),v.y))-y;"
   "return min(max(i.x,i.y),0.)+length(max(i,0.));"
 "}"
 "float l(vec3 v,vec3 y)"
 "{"
   "vec3 m=v;"
   "if(length(v)<20.)"
     "m=vec3(v.x,v.y,mod(v.z,y.z))-.5*y;"
   "return x(i(m+vec3(0.,3.3,0.),vec2(.2,4)),s(m+vec3(0.,-1.5,0.),vec2(.9,.2)));"
 "}"
 "vec2 h(in vec3 y)"
 "{"
   "vec3 i=vec3(y.xy,y.z-10.+mod(iGlobalTime*5.,40.));"
   "vec2 r=vec2(f(v(i,vec3(.34),.05),v(i,.55)),60.);"
   "r=x(r,vec2(y.y+5.,105.));"
   "r=x(r,vec2(m(y,vec3(.4,0.,0.)),300.));"
   "r=x(r,vec2(l(y,vec3(0.,-3,4.5)),210.));"
   "return r;"
 "}"
 "vec3 i(in vec3 v)"
 "{"
   "vec3 y=vec3(.001,0.,0.),i=vec3(h(v+y.xyy).x-h(v-y.xyy).x,h(v+y.yxy).x-h(v-y.yxy).x,h(v+y.yyx).x-h(v-y.yyx).x);"
   "return normalize(i);"
 "}"
 "float e(in vec3 v,in vec3 y)"
 "{"
   "float i=0.,f=1.;"
   "for(int r=0;r<5;r++)"
     "{"
       "float m=.01+.12*float(r)/4.;"
       "vec3 l=y*m+v;"
       "float x=h(l).x;"
       "i+=-(x-m)*f;"
       "f*=.95;"
     "}"
   "return clamp(1.-3.*i,0.,1.);"
 "}"
 "mat3 e(in vec3 y,in vec3 v,float i)"
 "{"
   "vec3 m=normalize(v-y),f=vec3(sin(i),cos(i),0.),r=normalize(cross(m,f)),x=normalize(cross(r,m));"
   "return mat3(r,x,m);"
 "}"
 "void main()"
 "{"
   "vec2 v=-1.+2.*gl_FragCoord.xy/iResolution.xy;"
   "v.x*=iResolution.x/iResolution.y;"
   "float y=iGlobalTime/3.;"
   "vec3 m=vec3(5.*sin(y),2.*sin(y)+1.,3.5*cos(y)),f=vec3(0.,0.,0.);"
   "mat3 r=e(m,f,0.);"
   "vec3 x=r*normalize(vec3(v.xy,1.5));"
   "float l=1.;"
   "for(int n=0;n<99;n++)"
     "{"
       "float c=h(m+x*l).x;"
       "if(c<.01||l>60.)"
         "break;"
       "l+=c;"
     "}"
   "vec3 n=vec3(.8,.9,1.);"
   "float z=1.;"
   "if(l<60.)"
     "{"
       "vec3 c=m+l*x,d=i(c),s=reflect(x,d);"
       "n=.45+.4*sin(vec3(.05,.42,.1)*(h(m+x*l).y-1.));"
       "const float g=.1,p=.4,a=.6,k=1.;"
       "float t=2.;"
       "vec3 o=normalize(vec3(-.6,.7,-.5));"
       "float b=max(0.,dot(d,o));"
       "if(b<g)"
         "b=0.;"
       "else"
         " if(b<p)"
           "b=p;"
         "else"
           " if(b<a)"
             "b=a;"
           "else"
             " b=k;"
       "float u=max(0.,dot(d,o+vec3(0,0,1)));"
       "u=pow(u,t);"
       "u=step(.5,u);"
       "vec3 R=n,F=n,C=n;"
       "n=R+b*F+u*C;"
       "n=pow(n,vec3(.845));"
       "gl_FragColor=vec4(n,.6);"
     "}"
   "else"
     " gl_FragColor=vec4(n,z);"
 "}";

#endif // SHADER_CODE_H_
